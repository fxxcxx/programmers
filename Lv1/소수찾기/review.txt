처음엔 소수찾기....만 인줄 알고 쉽네!! 했으나
생각해보면 소수를 찾으려면 응? 하나하나 나눠가면서 비교해야되 않나
이생각이 들었다.. 항사 코드를 짜기전에 생각을 많이 해보자.

처음엔 이중포문으로 코드를 작성했으나
제출해보니 끝쪽에서 타임아웃이 나더라.
개열받는다.

그래서 이악물고 어떻게 하지 고민하다가
사실 스터디원이 이 문제를 먼저 풀고 
에라토스테네스의 체 라는 알고리즘을 이용했다고 한다.

수학적인 지식이 필요한데, 지금 눈이 감겨서
일어나서  araboza… Zzz

그때 같이 sol.cpp 올리는 걸로!

----------------------------
n이 int형으로 선언되어있고
우리는 배열을 이용해 풀어야하므로

vector<int> num;

num에 0부터 n까지 넣는 작업
(0부터 넣어야 에라토스테네스 쓸 때 안헷갈림)

for(int i=0; i<=n; i++){
  num.push_back(i);
  }

에라토스테네스의 체 구현
    
for(int i=2; i<=n;i++){ //0과 1은 소수가 아니므로... 배열과 실제 숫자가 들어 있는 곳이 같게 하려고 0부터 넣음
  if (num[i]==0)//0이면 아래 작업이 완료된 것이다.
    continue; //continue는 위로 가서 작업 수행.
  for(int j=i+i; j<=n; j+=i ){ //i+i 해줘야 소수 자신은 남고 그 뒤로 배수만 없어짐!!
    num[j] = 0;
  }
}
    
for(int a=1; a<=n; a++){ //count 초기 값을 -1로 설정 했었음. 0과 1은 취급 X
  if(num[a]!=0) count++;  
  }
return count;
